# -*- coding: utf-8 -*-

"""Копия блокнота "hw-01.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14JXgDoXYkg9P7QM5PT8oTena3c6JxWbG

# Домашнее задание 01
## Примитивы языка

В этом блоке вам предстоит выполнить несколько небольших заданий на примитивы языка (арифметические выражения, переменные, ввод и вывод, логика, условия, циклы и функции). На каждую из конструкций будет дано одно или два задания, на выполнение каждого из которых должно по идее уйти не сильно много времени.

### 1. **Станки**

Есть два станка, первый изготавливает одну деталь за `x` секунд, второй &ndash; за `y` секунд. Известно, что с момента запуска обоих станков прошло `h` часов, `m` минут и `c` секунд.

1. Сколько деталей суммарно изготовили станки?
2. Через сколько секунд каждый из станков произведет очередную деталь?
3. Если в текущий момент остановить наиболее быстрый из двух станков, через какое время (часы, минуты, секунды) второй станок догонит его по количеству изготовленных деталей?
<br/>*Подсказка*: для определения того, какой из станков работает быстрее, можно воспользоваться условным оператором `if`. Для перевода количества секунд в (часы, минуты, секунды) достаточно деления нацело.

Напишите код, отвечающий на каждый из вопросов, в отдельной ячейке. Небольшие заготовки уже даны, вам надо только заменить `...` на соответствующие вычисления. Можно дописывать код, которого изначально не было в ячейке (например, `if ...:` в третьем задании).
"""

x, y = 10, 13
h, m, c = 1, 37, 58

# решение задания 1.
import math

time=3600*h+60*m+c
total_parts = time//x+time//y
print(total_parts)

# решение задания 2.
estimate_first = time%x
estimate_second = time%y
print(estimate_first, estimate_second)

# решение задания 3.
if(x<y):
    ost=time//x-time//y
    delta_h = (ost * y) // 3600
    delta_m = ((ost * y) - delta_h * 3600) // 60
    delta_s = (ost * y) - delta_h * 3600 - 60 * delta_m
else:
    ost = time//y-time//x
    delta_h = (ost * x) // 3600
    delta_m = ((ost * x) - delta_h * 3600) // 60
    delta_s = (ost * x) - delta_h * 3600 - 60 * delta_m

print(delta_h, delta_m, delta_s)

"""4. **Дополнительное задание**: реализуйте решение задания 3. без условного оператора `if`. Для этого могут понадобиться функции `abs` (модуль числа) и `min`/`max` (минимальный или максимальный из аргументов).

Если вы сразу написали решение без `if`, то реализуйте это задание в новой ячейке. Иначе можете следующую ячейку оставить без изменений.

**Дополнительные задания** не являются обязательными &ndash; их выполнение дает бонусные баллы, но если их пропускать, это не помешает получить полный балл за ДЗ.
"""
# решение задания 4.

ost=abs(time//x-time//y)
delta_h = (ost * max(x,y)) // 3600
delta_m = ((ost * max(x,y)) - delta_h * 3600) // 60
delta_s = (ost * max(x,y)) - delta_h * 3600 - 60 * delta_m
print(delta_h, delta_m, delta_s)

"""5. Реализуйте ввод для этого задания. А именно, запросите ввод с клавиатуры чисел `x` и `y` в первой строке (через пробел) и ввод с клавиатуры чисел `h`, `m` и `s` во второй строке (через двоеточие).
<br/> Например, если пользователь вводит
```
10 13
1:37:58
```
то у вас при исполнении ячеек с решениями должны получиться те же самые ответы.
"""

# решение задания 5.
x,y=map(int, input().split())
h, m, c = map(int, input().split(':'))

"""## 2. **Циклы и массивы**

Для каждого из следующих заданий определите, какой цикл (`for` или `while`) и по какой последовательности/по какому условию следует использовать, чтобы код решал поставленную задачу.

Пробуйте формулировать алгоритм решения задачи в виде псевдокода, понятного человеку. Например, если ваше решение будет звучать как &laquo;**пока** число больше нуля, умножить его на три или поделить на два&raquo;, то вам понадобится цикл `while`, внутри которого будут выполняться соответствующие умножения или деления. А если алгоритм звучит как &laquo;**для каждого** четного числа от `0` до `n` вывести квадрат от его половины&raquo;, то вам нужен цикл `for`, проходящий по всем четным числам от `0` до `n`.

**По умолчанию во всех заданиях будет изначально написан `while True`**, но это не значит, что в них во всех нужно использовать цикл `while`. Несмотря на то, что цикл `for` всегда можно заменить на цикл `while`, иногда просто код с циклом `for` более читабельный, потому что лучше отражает суть алгоритма. Постарайтесь использовать наиболее подходящий по смыслу цикл.

6. *Проверка числа на простоту*
<br> Для того, чтобы проверить число на простоту, достаточно проверить, что у него нет натуральных делителей, кроме единицы и его самого. Напишите нужный цикл.
"""

# решение задания 6.

n = 1000000007
is_prime = True
i=2
while (i*i<=n):
    if n % i == 0:
        is_prime = False
        break
    i+=1
if is_prime:
    print(f'{n} is a prime number!')
else:
    print(f'{n} is not a prime number :(')

"""7. **Дополнительное задание**: реализуйте проверку числа на простоту так, чтобы для `n = 1000000007`, проверка укладывалась в одну секунду (на самом деле даже с запасом). Это задание можно выполнить прямо в той же ячейке, не обязательно создавать новую.
8. [*Гипотеза Коллатца*](https://ru.wikipedia.org/wiki/Гипотеза_Коллатца)
<br> Поверим, что гипотеза верна. Посчитайте количество шагов, которое выполнит алгоритм из гипотезы Коллатца, прежде чем число `n` станет равно `1`.
"""

# решение задания 8.

n = 123456789
steps = 0
while (n!=1):
    if n % 2 == 0:
        n //= 2
    else:
        n = n * 3 + 1
    steps+=1
print(f'The number of steps is {steps}')

"""9. *Решето Эратосфена*
<br> Найдем все простые числа от `2` до `n`. Для этого пройдемся по всем числам в этом интервале, и для каждого пометим как составные все, делящиеся на него. Например, встречая `2`, мы помечаем все остальные четные числа как непростые.
<br> В конце алгоритм выводит все найденные простые числа.
"""

# решения заданий 9. и 10.

"""" №9 """
n = 1000000
is_prime = [True for i in range(n + 1)]
primes=[]
i=2
while i<n:
    if is_prime[i]:
        j=2
        while j*i<=n :
            is_prime[j*i] = False
            j+=1
        primes.append(i)
    i+=1

i=2
while i<n:
    if is_prime[i]:
        print(i, end=' ')
    i+=1
    
"""" №10 """
n = 1000000
is_prime = [True for i in range(n + 1)]
primes=[]
i=2
while i<n:
    if is_prime[i]:
        j=2
        while j*i<=n :
            is_prime[j*i] = False
            j+=1
        primes.append(i)
    i+=1
    primes.sort()
print(primes)

"""10. Измените код в предыдущей ячейке так, чтобы у вас создавался массив `primes`, содержащий все простые числа от `2` до `n` в порядке возрастания.
11. Используя [срезы](https://python-reference.readthedocs.io/en/latest/docs/brackets/slicing.html) и [другие методы массивов](https://python-reference.readthedocs.io/en/latest/docs/list/), выведите
    * массив из первых десяти простых в порядке возрастания
    * массив, состоящий из всех простых от `37` до `239` включительно
    * массив из последних десяти простых в порядке убывания

**Не надо** в явном виде выписывать первые/последние десять простых или находить индексы простых `37` и `239`. На защите домашки должна быть возможность моментально изменить код при изменении любых из этих констант.
"""

# решение задания 11.
print(primes[0:10])
print(primes[13:52])
print(primes[-1:-11:-1])

"""## 3. **Рефакторинг**

Ниже (не в следующей ячейке, чуть дальше) задан кусок кода, написанный очень неэффективно. Какие-то значения вычисляются много раз, какие-то части кода повторяются.

Проведите рефакторинг этого кода, используя *переменные* и *функции*. Напомним, что переменные &ndash; это просто способ сохранить значение, чтобы потом его переиспользовать, а функция &ndash; это способ &laquo;дать имя&raquo; определенной последовательности действий, чтобы потом по этому имени ее вызывать.

Для тех, кто не успел дойти до простых функций на прошлой паре, ниже есть пример их использования:
"""

for i in range(10):
    print(i, end='')
for i in range(10):
    print(i, end='')
for i in range(10):
    print(i, end='')

"""В этом коде один и тот же цикл используется трижды. Вместо того, чтобы трижды писать одни и те же строчки кода, можно &laquo;назвать&raquo; это действие `print_range_10` с помощью ключевого слова `def`:
```py
def print_range_10():
    for i in range(10):
        print(i, end='')
```
после чего код можно будеть переписать как
"""

def print_range_10():
    for i in range(10):
        print(i, end='')

print_range_10()
print_range_10()
print_range_10()

"""Это увеличивает читабельность кода, потому что
* сокращается его объем;
* у больших частей кода появляется понятное имя, по которому можно разобраться, что они делают, быстрее, чем просто прочитав код от начала и до конца.

Итак, код, который вам предстоит порефакторить, ниже.

12. Скопируйте код из следующей ячейки в ячейку на один ниже. В ней попробуйте сократить код как можно больше, чтобы он при этом стал более читаемый, но его функциональность не изменилась.
<br/>В конце проверьте, что исходный код и ваша версия выводят одно и то же при запуске. Позапускайте код на разных `a`, чтобы убедиться, что вывод не меняется в зависимости от исходного массива `a`.
<br/>*Подсказка*: последний `print` не внутри условия. Чтобы вынести как можно больше общего кода в функцию, возможно, вам придется к этому условию добавить `else`. Распишите на бумажке поведение программы в разных сценариях, и поймете, в каких сценариях этого вывода будет не хватать.

13. **Дополнительное задание**: посмотрите на стандартные встроенные функции, которые вам доступны, и сократите код так, чтобы в нем было не более одного знака `+`.

"""

# исходный код
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
if (a[0] + a[1] + a[2] + a[3] + a[4]) * (a[0] + a[1] + a[2] + a[3] + a[4]) > 100:
    for i in range(10):
        a[i] += i
    print(a)
if (a[0] + a[1] + a[2] + a[3] + a[4]) * (a[5] + a[6] + a[7] + a[8] + a[9]) < 10000:
    print(a)
    for i in range(10):
        a[i] += i
    print(a)
if (a[5] + a[6] + a[7] + a[8] + a[9]) * (a[5] + a[6] + a[7] + a[8] + a[9]) > 1000:
    for i in range(10):
        a[i] += i
print(a)  # да, оно специально на таком отступе

# отрефакторенный код

def usl(a, begin1, end1, begin2, end2,):
    sum1=0
    sum2=0
    for i in range(begin1,end1):
        sum1+=a[begin1]
    for i in range(begin2,end2):
        sum2+=a[begin2]
    return sum1*sum2

def rang10(x):
    for i in range(x):
        a[i]+=i

a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

if usl(a,0,4,0,4)> 100:
    rang10(10)
    print(a)
if usl(a,0,4,5,9) < 10000:
    print(a)
    rang10(10)
    print(a)
if usl(a,5,9,5,9) > 1000:
    rang10(10)
print(a)

"""# Крестики-нолики

В этом блоке вам предстоит немного поиграть с крестиками-ноликами, которые были реализованы на практике.

Возьмите любой код крестиков-ноликов, рассмотренный на парах (если ваш преподаватель вам не выкладывал код с практики, возьмите одну из двух [версий в канале](https://t.me/phystechprog2023/21)). Больше рекомендуется версия с пары в 15:20, в ней более общий код для проверки победы.

14. Скопируйте себе блокнот с пары, позапускайте код. Попробуйте вносить какие-то маленькие изменения, посмотрите, как меняется поведение программы. Ваша цель &ndash; достигнуть понимания происходящего. Особенно касается функции, которая проверяет факт победы: можете раскомментировать вывод и посмотреть, какая строчка в какой момент исполняется и за что отвечает.
"""
import random
GameFild=[["_","_","_"],["_","_","_"],["_","_","_"]]
AI='0'
Player='X'
StrokeNumber=0

def ChackGamigState(GameFild):
    for i in range(3):
        if (GameFild[i][0]==GameFild[i][1]==GameFild[i][2] and GameFild[i][0]!="_"):
            return 1
        if (GameFild[0][i]==GameFild[1][i]==GameFild[2][i] and GameFild[0][i]!="_"):
            return 1
    if (GameFild[0][0] == GameFild[1][1] == GameFild[2][2] and GameFild[1][1] != "_"):
        return 1
    if (GameFild[0][2] == GameFild[1][1] == GameFild[2][0] and GameFild[1][1] != "_"):
        return 1
    return 0
    #___________________________________________________________________________________________________________________
def PlayerTurn (GameFild):
    global StrokeNumber
    print("It's your turn now")
    while(1):
        x=input("Enter the column number ")
        y=input("Enter the line number ")
        if (int(y) >= 1 and int(y) <= 3 and int(x) >= 1 and int(x) <= 3):
            if(GameFild[int(y)-1][int(x)-1]=="_"):
                GameFild[int(y)-1][int(x)-1]=Player
                break
            else:
                print("This field is already occupied, enter another one")
        else:
            print("Incorrect data entry")

    StrokeNumber+=1
    #___________________________________________________________________________________________________________________
def PrintField(GameFild):
    print("    1   2   3")
    for i in range(3):
        print(i+1,"|",GameFild[i][0],"|",GameFild[i][1],"|",GameFild[i][2],"|")
    # ___________________________________________________________________________________________________________________

def ChackWinTurn(GameFild, Player):
    for i in range(3):
        if ((GameFild[i][0] == GameFild[i][1] == Player and GameFild[i][2] == "_") or (GameFild[i][0] == GameFild[i][2] == Player and GameFild[i][1] == "_") or (GameFild[i][2] == GameFild[i][1] == Player and GameFild[i][0] == "_")):
            for j in range(3):
                if(GameFild[i][j]=="_"):
                    GameFild[i][j]=AI
            return 1
        if ((GameFild[0][i] == GameFild[1][i] == Player and GameFild[2][i] == "_") or (GameFild[0][i] == GameFild[2][i] == Player and GameFild[1][i] == "_") or (GameFild[2][i] == GameFild[1][i] == Player and GameFild[0][i] == "_")):
            for j in range(3):
                if(GameFild[j][i]=="_"):
                    GameFild[j][i]=AI
            return 1
    if ((GameFild[0][0] == GameFild[1][1] == Player and GameFild[2][2] == "_") or (GameFild[1][1] == GameFild[2][2] == Player and GameFild[0][0] == "_") or (GameFild[0][0] == GameFild[2][2] == Player and GameFild[1][1] == "_")):
        for j in range(3):
            if (GameFild[j][j] == "_"):
                GameFild[j][j] = AI
        return 1
    if ((GameFild[0][2] == GameFild[1][1] == Player and GameFild[2][0] == "_") or (GameFild[2][0] == GameFild[1][1] == Player and GameFild[0][2] == "_") or (GameFild[2][0] == GameFild[0][2] == Player and GameFild[1][1] == "_")):
        for j in range(3):
            if (GameFild[j][2-j] == "_"):
                GameFild[j][2-j] = AI
        return 1
    return 0
    #___________________________________________________________________________________________________________________
def AITurn(GameFild):
    global StrokeNumber
    global AI
    global Player
    print("Now is AI turn ")
    turn=1
    if(ChackWinTurn(GameFild,AI)):
        turn=0
    if(turn and ChackWinTurn(GameFild,Player)):
        turn=0
    if (turn and GameFild[1][1]=="_"):
        turn=0
        GameFild[1][1]=AI
    if (turn and GameFild[0][0]=="_"):
        turn = 0
        GameFild[0][0] = AI
    if (turn and GameFild[2][2]=="_"):
        turn = 0
        GameFild[2][2] = AI
    if (turn and GameFild[0][2]=="_"):
        turn = 0
        GameFild[0][2] = AI
    if (turn and GameFild[2][0]=="_"):
        turn = 0
        GameFild[2][0] = AI
    if(turn):
        while (1):
            a=random.randint(0,8)
            x=a%3
            y=a//3
            if (GameFild[y][x]=="_"):
                GameFild[y][x]=AI
                turn=0
                break
    StrokeNumber += 1
    # ___________________________________________________________________________________________________________________
def main(GameFild):
    global StrokeNumber
    PrintField(GameFild)
    while(1):
        PlayerTurn(GameFild)
        if(StrokeNumber==9):
            if(ChackGamigState(GameFild)==0):
                PrintField(GameFild)
                print("Drow")
                return 0
            else:
                if (StrokeNumber%2!=0):
                    PrintField(GameFild)
                    print("You Win")
                    return 0
                else:
                    PrintField(GameFild)
                    print("AI Win")
                    return 0
        else:
            if (ChackGamigState(GameFild)==1):
                if (StrokeNumber%2!=0):
                    PrintField(GameFild)
                    print("You Win")
                    return 0
                else:
                    PrintField(GameFild)
                    print("AI Win")
                    return 0

        PrintField(GameFild)
        AITurn(GameFild)

        if(StrokeNumber==9):
            if(ChackGamigState(GameFild)==0):
                PrintField(GameFild)
                print("Drow")
                return 0
            else:
                if (StrokeNumber%2!=0):
                    PrintField(GameFild)
                    print("You Win")
                    return 0
                else:
                    PrintField(GameFild)
                    print("AI Win")
                    return 0
        else:
            if (ChackGamigState(GameFild)==1):
                if (StrokeNumber%2!=0):
                    PrintField(GameFild)
                    print("You Win")
                    return 0
                else:
                    PrintField(GameFild)
                    print("AI Win")
                    return 0

        PrintField(GameFild)

main(GameFild)
"""
15. **Дополнительное задание** (но на большое количество бонусных баллов): скопируйте код крестиков-ноликов в этот блокнот. Реализуйте одну из двух модификаций на выбор:
    * поле 5 на 5, для победы нужно иметь три одинаковых символа в ряд
    * случайный выбор очередности ходов + компьютер должен играть оптимально, а не случайно

*Подсказка* к первому варианту: каждая выигрышная полоса может быть задана с помощью стартовой клетки и направления. Направление можно задать парой `(delta_y, delta_x)`, например, `(1, 0)` &ndash; это направление вниз. Стартовая клетка и направление являются корректной парой, если конец соответствующей полосы не выходит за границы поля, что можно проверить с помощью `if`.

*Подсказка* ко второму варианту: оптимальный ход задается текущим состоянием поля. При чем в некоторых случаях для разных вариантов текущего поля выгодно сделать один и тот же ход (различных состояний поля чуть меньше, чем `3^9 = 19683`, а возможных ходов всегда не больше девяти). Постарайтесь найти общие критерии для оптимальности каждого хода, и реализовать его выбор как можно компактнее.
<br/>Альтернативно, можно реализовывать более общую честную стратегию &ndash; если у противника есть шанс выиграть, надо его закрыть, иначе &ndash; попробовать добиться лучшей ситуации для себя.
"""

